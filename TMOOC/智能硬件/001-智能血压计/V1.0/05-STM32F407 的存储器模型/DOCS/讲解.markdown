# STM32F407 的存储器模型 #

## STM32F407 的存储器模型 ##

- 存储器组织结构
- 启动配置与存储器映射
- 位带区

学习嵌入式系统开发的初期，经常会有这样的疑问：微处理器运行时从哪里取得的指令，写好程序后应该放到哪里？变量在哪个区域？了解微处理器的存储器模型，有助于找到这些问题的答案。

嵌入式系统中的微处理器一般采用线性的空间管理方式，也就是内存，设备寄存器等统一编址在一个空间，了解微处理器的存储器模型有助于我们弄清楚其存储空间划分，我们就可以知道什么设备在什么地址空间、也就可以弄清楚，需要把代码、变量等分配到哪个空间范围。

关于STM32F407微处理器的存储器模型主要介绍一下结构方面的内容：

- 存储器组织结构
	+ ARM Cortex-M4的存储空间划分
	+ STM32F407的存储器空间划分
- STM32F407的启动配置和启动时存储器映射
- 位带区
	+ ARM Cotex-M4不像8051那样有位变量，但是其为能以原子操作完成对寄存器、变量的某个位的修改，引入了新的解决方案：“位带区”。

### 存储器组织结构 ###

#### ARM Cortex-M4的存储空间划分 ####

大家知道，嵌入式系统应用广泛，而且比较杂，其标准化程度也低。这样就使得嵌入式系统开发比较复杂，同时软件的复用度也低。ARM公司在设计微控制器核心时希望尽量提高标准化程度，提高软件的兼容性，他们在设计ARM Cortex-M系列处理器时，制定了很多规范，要求采用ARM cortex-M核心设计MCU的公司，必须遵守。存储器空间划分就是其规范的一部分。

在ARM Cortex-M4中，程序存储器、数据存储器、寄存器和 I/O 端口排列在同一个顺序的 4 GB 地址空间内，采用小端格式。

对不同地址空间的使用，也做了框架性的规定。如图：
ARM Cortex-M4把存储空间分为：
1、片内设备区
	ROM、Flash、RAM、片内设备寄存器
	位带区
2、片外设备区
   

#### STM32F407 存储空间划分 ####
STM32F407的存储空间划分是在ARM cortex-M4框架之下的，可以看到：

0xE0000000 区域是ARM Cortex-M4的系统寄存器区

0x60000000-0xDFFFFFFF是外部存储器和设备区

0x40000000-0x5FFFFFFF是STM32F407片上设备区，
                       含位带区0x40000000-0x400FFFFF；

0x20000000-0x3FFFFFFF是片内内存区，含位带区,0x20000000-0x200FFFFF

0x00000000-0x1FFFFFFF是片内存储器区，该区分为几段。

Option bytes区

System memory+OTP （系统存储器里面存放ST公司已经编写好的程序）

CMM 核心耦合内存区（效率高，只能存数据，不能执行代码（M3课指向代码，M4不可以））

Flash 区

0x00000000-0x00FFFFFF 启动区，ARM Cortex-M4异常向量表默认是在地址0，上电后ARM Cortex-M4到地址0找异常向量表，从地址0取得栈顶位置，并从地址4获得第一条指令开始执行。

STM32F407也是按此设计，将地址0开始的一个区域作为代码区。STM32F407中这段区域没有放任何物理设备，这段地址区根据不同的启动方式，映射到对应的设备上。
比如，如果采用从片上Flash启动时，地址0开始的1M字节区，将映射到片上Flash上。
也就是访问地址0开始到1M范围内的区域时，访问的物理设备将是片上Flash。
关于启动的相关内容将在下一节介绍。



### 启动配置与存储器映射 ###

#### STM32F407 自举配置&存储器映射 ###

由于ARM cortex-M4核是没有MMU的，所以采用固定存储器映射方式。
地址0是代码区，0x20000000开始的区域是数据区。
地址0开始的启动区这段空间可以根据不同的启动方式映射到不同设备。

STM32F407可以支持从片上FLash，系统存储器，RAM区启动。

STM32F407怎么知道我们希望从什么设备上启动呢？

为了解决这个问题，STM32F407提供两个引脚，BOOT0和BOOT1，STM32F407通过识别这两个管脚上的高、低电平来决定地址0映射到哪个设备上。
如右图，以LQFP100封装的STM32F407为例，BOOT0就是94号引脚，BOOT1就是37号引脚。BOOT0只能作为启动选项配置引脚，没有别的功能。BOOT1则是和通用输入输出口的PB2复用，就是启动时STM32F407将BOOT1作为启动配置引脚，启动后软件可以把37号管脚作为通用输入输出口PB2使用。

1、当BOOT0接低电平时，不论BOOT1接低电平还是高电平，STM32F407都从
   片上Flash启动（地址0映射到片上flash）

2、当BOOT0接高电平，BOOT1接低电平时，STM32F407从系统存储器启动，
   地址0映射到系统存储器区

3、当BOOT0接高电平，BOOT1接高电平时，STM32F407从片上RAM启动
   地址0映射到片上RAM区

#### STM32F407 自举配置&存储器映射（续）####
如前所述，启动时，BOOT0，BOOT1两个引脚配置不同，就可以决定从不同的设备上启动，也就是地址0会相应的映射到对应的设备，这是STM32F407硬件自动完成的。我们来简单看一下具体的映射关系：

我们看到只有启动区映射可以调整，其他都是固定的。
如当BOOT0接低电平时，地址0开始的1M字节区映射到片上Flash区。
访问地址0就是访问片上Flash。这里需要指出的是，访问地址0x08000000地址也是可以访问片上Flash的。

同理：
BOOT0接高电平，BOOT1接低电平时，地址0映射到系统存储器，启动时STM32F407就从系统存储器读取指令并执行了。这个系统存储器时里面放的代码是ST公司开发的在STM32F407出场时就已经保存到里面的。这段代码是具有特殊功能的启动程序，在后面的课程中我们在具体介绍。

当BOOT0接高电平、BOOT1接高电平时，地址0映射到SRAM1区域。这种启动方式一般用于特殊用途，比如调试阶段。

#### STM32F407 存储器重映射 ####

除了启动时有BOOT0、BOOT1两个引脚可以决定地址0区域的映射方式外，STM32F407还支持重映射。所谓重映射就是系统启动后，通过软件修改重映射寄存器（SYSCFG）来修改地址映射方式。因为是系统启动后，通过软件修改寄存器来实现启动区空间的重新映射关系，所以成重映射。当使用重映射方式进行映射时，BOOT0、BOOT1引脚的状态将不再影响启动区的映射关系。

#### ELink407 开发板启动模式配置 ####

我们课程的案例代码是在ELink407这个开发板上调试的，ELink407采用的是STM32F407这个cpu，ELink407开发板如何配置其启动方式呢？其实就是通过改变BOOT0，BOOT1引脚的电平状态。ELink407开发板BOOT0，BOOT1引脚电路截图如下：
跳线J35和J36就是控制BOOT0，BOOT1引脚电平的开关。
如：将J36跳线的，1和2脚连接，BOOT0就通过上拉电阻R71接到了3.3v电源上，
这样，BOOT0就是高电平。如果将1和2断开，2和3连接BOOT0就通过下拉电阻R70接到了地，就是低电平。

同理：J35跳线可以控制BOOT1的高低电平。


### 位带区 ###

#### STM32F407存储器位带区 ####

ARM Cortex-M4设计有位带区，当然这个位带区并不是像8015那样，支持位变量。由于ARM是采用RISC（精简指令集设计思想的），其运算如加法，减法，位运算，比较等都是在ARM核内的寄存器中完成的。要修改内变量中的某位时，通常我们要遵循读取->修改->写回的方式。    
1、把内存中的变量读取到ARM和的寄存器中    
2、在ARM核寄存器中修改要修改的位（保持其他不需要修改的位不变）    
3、将ARM核寄存器中修改完的值写回到内存中。    

unsigned int a;

修改a的bit0为0

a = a & 0xFFFFFFFE;    

ldr   r0, =a    
ldr   r1, [r0]    
bic   r1, r1, #0x1    
str   r1, [r0]    








